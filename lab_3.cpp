// №1 <Ускова 2019 С++>, стр[27], задания для самостоятельной работы.
// Выполнил студент второй группы Туз. А. Е.

#include <iostream>
#include <math.h> // а вдруг пригодится?



using std::cout; 
using std::cin;
using std::endl; // а вдруг пригодится? X2
using std::system; // НУ НУЖНО! а как я по вашему буду ловить консоль? не getchr() же! потоки - моветон!
using std::abs;
using std::pow;



#define PI 3.14
auto main() -> int {
    setlocale(LC_ALL, ".UTF8"); // ну мы же хотим использовать русские буковки?
    short epsPow{0}, sign{1}; // степень 1e-epsPow и знак.
    double sN{1}, sE{1}, sEp10{1}, x{0}, eps{0}, epsP10{0}, xN{1}; // инициализация - агрегатная - (компилятор ругай меня полностью!)
    long double slug{0}; // Картечь 8мм.. кхм то есть шаг для счёта с погрешностью.
    unsigned long long numItera{0}, epsItera{0}, epsP10Itera{0}, nFact{1}; // без знаковое - 8 байт (а почему-бы и нет?)

    cout << "Так, будьте добры ввести 3 числа через пробел," << endl 
         << "(если хотите ввести вещественные кроме X - ненадо - пожалуйста они всё равно порежуться в лучшем случае)" << endl
         << "первое введённое вами число - это X который будет подставлен в функцию." << endl
         << "второе введённое вами число - это количество итераций (неотрицательное) которые выполнит цикл-счёта ряда." << endl
         << "третье введённое вами число (0<=N<=12) это точность - до какого знака будет идти подсчёт"<<endl
         << "Пример ввода: <число1> <число2> <число3> <==> 10 7 2" << endl
         << "после ввода - нажмите ENTER" << endl
         << "Ваш ввод: ";

    cin >> x >> numItera >> epsPow; // надеюсь... ввод прошёл успешно и НИКТО не додумался пихать туда буковки.

    if (epsPow > 12){
        cout << "Просил - же! - железяке больно!" << endl;
        system("pause");
        return 0;
    }

    eps = pow(10, -abs(epsPow)); // ну а вдруг кто отрицательное введёт? сделаем вид что так и задуманно - да...
    epsP10 = eps/10; // ну тут всё ясно думаю. на порядок меньше.
    
    x = fmod(x, 2*PI);

    for (int itera=1; itera<=numItera; ++itera){ // пожалейте железяку.
        xN *= x*x; // подсчёт текущего X
        nFact = nFact * (2*itera) * (2*itera + 1); // подсчёт факториала
        sign = -sign; // инверсия знака
        sN += sign * xN / nFact; //подсчёт суммы для итеративного метода
    }
    
    sign = -1; // сбросим знак пожалуй.
    nFact = 6; // факториал туда-же. не будем же мы плодить сущности?
    xN = x*x; // по той-же причине

    slug = sign * (xN) / nFact; // первый шаг посчитаем заранее.
    while (eps < abs(slug) && epsItera < 15){ // вторая проверка - что-бы не убится о переполнение.
        sE += slug; //подсчёт суммы для итеративного метода
        ++epsItera; // итерации надо не забывать инкрементировать
        sign = -sign; // знак переворачиваем)
        xN *= x*x; // ну это - повышаем x на 2 степени
        nFact *= (2*epsItera+2) * (2*epsItera + 3); // считаем факториал для нашего шага
        slug = sign * xN / nFact; // заряжаем картечь!
        //cout << slug << endl;
    }


    sEp10 = sE;
    epsP10Itera = epsItera;
    while (epsP10 < abs(slug) && epsP10Itera < 15){ 
        sEp10 += slug; //подсчёт суммы для итеративного метода
        ++epsP10Itera; // итерации надо не забывать инкрементировать
        sign = -sign; // знак переворачиваем)
        xN *= x*x; // ну это - повышаем x на 2 степени
        nFact *= (2*epsP10Itera+2) * (2*epsP10Itera + 3); // считаем факториал для нашего шага
        slug = sign * xN / nFact; // заряжаем картечь!
    }
    
    cout << "Итеративное: " << sN << " Шагов затрачено: " << numItera << endl;
    cout << "Погрешность eps: " << sE << " Шагов затрачено: " << epsItera << endl;
    cout << "Погрешность eps/10: " << sEp10 << " Шагов затрачено: " << epsP10Itera << endl;

    system("pause"); // пауза на посмотреть - что там вывелось?
    return 0;
}
